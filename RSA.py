import random

# Vérifie si un nombre est premier
def est_premier(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# Trouve un nombre premier aléatoire dans un intervalle donné
def trouver_premier(min, max):
    p = random.randint(min, max)
    while not est_premier(p):
        p = random.randint(min, max)
    return p

# Calcule l'inverse modulaire de a modulo m
def inverse_modulaire(a, m):
    m0, x0, x1 = m, 0, 1
    while a > 1:
        q = a // m
        m, a = a % m, m
        x0, x1 = x1 - q * x0, x0
    return x1 + m0 if x1 < 0 else x1

# Calcule le PGCD de deux nombres
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# Génère la paire de clés publique et privée à partir de deux nombres premiers
def generer_cles(p, q):
    if not (est_premier(p) and est_premier(q)):
        raise ValueError('Les deux nombres doivent être premiers.')
    elif p == q:
        raise ValueError('p et q ne doivent pas être égaux.')

    n = p * q  # Calcul du produit des deux nombres premiers
    k = (p - 1) * (q - 1)  # Calcul de l'indicatrice de Euler

    # Choisir e tel que e est copremier avec k et 1 < e < k
    e = 2
    while gcd(k, e) != 1:
        e += 1

    # Calculer d, l'inverse modulaire de e modulo k
    d = inverse_modulaire(e, k)

    # Retourner la clé publique (e, n) et la clé privée (d, n)
    return ((e, n), (d, n))

# Chiffre un message en utilisant la clé publique
def chiffrer(pk, message):
    key, n = pk
    message_chiffre = [pow(ord(char), key, n) for char in message]
    return message_chiffre


# Déchiffre un message chiffré en utilisant la clé privée
def dechiffrer(pk, message_chiffre):
    key, n = pk
    message_dechiffre = ''.join([chr(pow(char, key, n)) for char in message_chiffre])
    return message_dechiffre

