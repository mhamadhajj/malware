import random

# Check if a number is prime
def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# Find a random prime number within a given range
def find_prime(min_val, max_val):
    p = random.randint(min_val, max_val)
    while not is_prime(p):
        p = random.randint(min_val, max_val)
    return p

# Calculate the modular inverse of a modulo m
def modular_inverse(a, m):
    m0, x0, x1 = m, 0, 1
    while a > 1:
        q = a // m
        m, a = a % m, m
        x0, x1 = x1 - q * x0, x0
    return x1 + m0 if x1 < 0 else x1

# Calculate the greatest common divisor of two numbers
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# Generate public and private key pair from two prime numbers
def generate_keys(p, q):
    if not (is_prime(p) and is_prime(q)):
        raise ValueError('Both numbers must be prime.')
    elif p == q:
        raise ValueError('p and q cannot be equal.')

    n = p * q  # Compute the product of the two prime numbers
    k = (p - 1) * (q - 1)  # Compute Euler's totient function

    # Choose e such that e is coprime with k and 1 < e < k
    e = 2
    while gcd(k, e) != 1:
        e += 1

    # Compute d, the modular inverse of e modulo k
    d = modular_inverse(e, k)

    # Return the public key (e, n) and the private key (d, n)
    return ((e, n), (d, n))

# Encrypt a message using the public key
def encrypt(pk, message):
    key, n = pk
    encrypted_message = [pow(ord(char), key, n) for char in message]
    return encrypted_message

# Decrypt an encrypted message using the private key
def decrypt(pk, encrypted_message):
    key, n = pk
    decrypted_message = ''.join([chr(pow(char, key, n)) for char in encrypted_message])
    return decrypted_message